#summary How to use Flow Control functionality in diStorm

This page covers the advanced functionality that the new interface of diStorm3 supplies. This is the time to say that diStorm, as a stream disassembler, doesn't do the flow control analysis work for you, but it will help you do that more easily.

The Decompose function requires the caller to pass a CodeInfo structure. In that structure there are all the parameters you pass normally to the Decode function and in addition there's a new parameter (or field) named 'features'. This is a flags parameter, so you can pass along a few flags together to control the way diStorm returns the disassembled instructions.

Let's list the possible decode flags:
Note that you can combine any of the flags below, except DF_MAXIMUM_ADDR16 with DF_MAXIMUM_ADDR32.

<b>DF_NONE</b>
 * If you don't want to use this stuff, just set this flag, and the Decompose will work normally. That is, like the Decode function, but return structure output.

<b>DF_MAXIMUM_ADDR16</b>
 * If you decode 16 bits code, you can limit the addresses range to 16 bits.
 * For instance, if you have a piece of code that JMPs backwards to a negative offset, instead of getting something like 0xfffffffff, you will get 0xffff. Or only the low 16 bits of the address.
 * This is mostly good for display.

<b>DF_MAXIMUM_ADDR32</b>
 * Nowadays that we got 64 bits decoding as well, we sometimes want to limit addresses to 32 bits. Works like DF_MAXIMUM_ADDR16 but for 32 bits.

<b>DF_RETURN_FC_ONLY</b>
 * This is the most important flag IMHO. What it really does is telling the Decompose function that it should return only flow control instructions back to the caller, and filter the rest of them.
 * Effectively, you will get only the branch and similar instructions, making it easier to track flow control code.

<b>DF_STOP_ON_CALL</b>
 * Makes the Decompose function return to the caller when a CALL/FAR instruction was decoded.

<b>DF_STOP_ON_RET</b>
 * Makes the Decompose function return to the caller when a RET/IRET/RETF instruction was decoded.

<b>DF_STOP_ON_SYS</b>
 * Makes the Decompose function return to the caller when a SYSENTER/SYSEXIT/SYSCALL/SYSRET instruction was decoded.

<b>DF_STOP_ON_BRANCH</b>
 * Makes the Decompose function return to the caller when a JMP/FAR instruction was decoded.

<b>DF_STOP_ON_COND_BRANCH</b>
 * Makes the Decompose function return to the caller when a conditional branch (Jxx, JCxx, LoopXX) instruction was decoded.

<b>DF_STOP_ON_INT</b>
 * Makes the Decompose function return to the caller when an interrupt instruction (INT, INTO, INT1, INT3, UD2) was decoded.

<b>DF_STOP_ON_FLOW_CONTROL</b>
 * Makes the Decompose function return to the caller when any of the above instructions are decoded.

----
Note that most of the flags are telling the Decompose function when to *stop* decoding. However, the only filter is the <i>DF_RETURN_FC_ONLY</i> flag. Currently, there's no other way to filter all instruction except a specific type of instructions.

Suppose you want to get the target address of a call instruction in a specific code block:
{{{
mov eax, 1
push eax
push 0
lea eax, [ebp+10]
push eax
call some_function
}}}

You can call the Decompose function with the DF_STOP_ON_CALL and DF_RETURN_FC_ONLY. Which will return only the CALL instruction, in this case(!). This is quiet good if you know there are no flow control instructions in the stream, except the one you're interested in.
So basically what you can do next, is to check that the <i>last</i> instruction in the results array, is the call instruction.
There are two ways to check for that, either by comparing the 'opcode' field to I_CALL, or by checking the 'meta' field with the helper macro META_GET_FC and compare the result to FC_CALL. Then once you're sure it's the instruction you were looking for you can get the target address, by using another helper macro, INSTRUCTION_GET_TARGET. So eventually you will get, by our example, the address of 'some_function'.

That's why also the meta information of the instruction is very important to flow control, so you know whether the instruction you're just examining is flow control related. The META_GET_FC returns one of the following values:
FC_NONE, FC_CALL, FC_RET, FC_SYS, FC_BRANCH, FC_COND_BRANCH and FC_INT.
They are self explanatory and notice that there FC_BRANCH and FC_COND_BRANCH, so you can easily distinguish between the two cases of <i>always-branch</i> to <i>conditional-branch</i>.