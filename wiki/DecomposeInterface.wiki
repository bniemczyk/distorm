#summary A must read for using the Decompose interface.

In this page I'm going to cover how to parse the Decompose output.

Valid instructions
Invalid instructions
Basic fields
Use macros


struct _DInst:

<b>_OffsetType addr;</b>
 * Always set.
 * The virtual address of the instruction.
 * It is determined according to the given start address of the call to the Decompose function.

<b>uint8_t size;</b>
 * Always set.
 * The size of the whole instruction. Varying from 1 to 15 bytes long.

<b>uint16_t flags;</b>
 * Always set.
 * Very important to check this field before touching the other fields.
 * If it's set to FLAG_NOT_DECODABLE, the instruction is invalid.
 * See [DecomposeInterface#Flags] for more information.

<b>uint8_t segment;</b>
 * Set when one of the operands is of type O_SMEM, O_MEM, O_DISP.
 * Helper macros: SEGMENT_GET, SEGMENT_IS_DEFAULT.
 * SEGMENT_IS_DEFAULT returns TRUE if the segment register is the default one for the operand. For instance: {{{MOV [EBP], AL}}} - the default segment register is SS. However, {{{MOV [FS:EAX], AL}}} - The default segment is DS, but we overrode it with FS, therefore the macro will return TRUE.
 * To extract the segment register index use the SEGMENT_GET macro.
 * R_NONE if not set.

<b>uint8_t base;</b>
 * Set when one of the operands is of type O_MEM.
 * It is the register index of the Base. I.E: {{{MOV [EAX+EBX*4], EDI}}} - it is R_EAX.
 * R_NONE if not set.

<b>uint8_t scale;</b>
 * Set when one of the operands is of type O_MEM.
 * The Scale is a pair to the Index register in a memory indirection operand, which is described in the Operand structure.
 * The scale can be either 0, 1, 2, 4, 8. If it's not set it is 0.

<b>uint8_t dispSize;</b>
 * Set when one of the operands is of type O_SMEM, O_MEM, O_DISP and the instruction has a displacement.
 * This is the size of the 'disp' field in bytes.
 * If there's no displacement set, this field is 0.

<b>uint16_t opcode;</b>
 * Always set.
 * If the instruction is invalid it is set to I_UNDEFINED.
 * Include the file "mnemonics.h" to use the Instructions-Enum.
 * An helper macro to get the textual representation for an instruction is GET_MNEMONIC_NAME.
 * For instance, if you want to check that a decomposed instruction is 'POP', then compare this field to I_POP. Basically add a prefix of "I_" to the upcased name of the instruction you want to check. You can see the whole list in the "mnemonics.h" file.

<b>{{{_Operand ops[OPERANDS_NO];}}}</b>
 * An array of 4 _Operand's.
 * However, they might be empty.
 * See [DecomposeInterface#Operands] for more information.

<b>uint64_t disp;</b>
 * Set when one of the operands is of type O_SMEM, O_MEM, O_DISP and the instruction has a displacement.
 * The only way to know that an instruction as a displacement is to check that dispSize != 0.
 * Some instructions use a displacement of 0. I.E: {{{MOV [EBP], EAX}}}.

<b>_Value imm;</b>
 * Set when one of the operands is of type O_IMM, O_IMM1&O_IMM2, O_PTR, O_PC.
 * The size of the immediate value itself is the Operand.size field.
 * See [DecomposeInterface#Immediate] for more information.

<b>uint16_t unusedPrefixesMask;</b>
 * Always set.
 * This field indicates which of the prefixes of the instruction were unused.
 * There are two reasons as for why a prefix is unused, either because it didn't affect the decoding of the instruction. I.E: db 0x66; ADD AL, 1. The 0x66 (Operand Size) prefix doesn't affect the instruction in this case and therefore is unused. The other reason is when there are more than one prefix of the same type (see x86 documentation). I.E: db 0x2e, db 0x3e, MOV [EAX], AL. We tried to set a segment override twice, so only the last one (0x3e) is taken into account, the first one is unused.
 * Normally instructions *should not* have unused prefixes. It might mean that you disassemble invalid code (or data). Or it might mean you disassemble an aligning instruction such as: 0x66, 0x66, 0x90 to fill in a space of 3 bytes to round up to next multiple of 8/16, etc.
 * A quick check to see if the instruction has unused prefixes is 'unusedPrefixesMask != 0'.
 * So which prefixes are unused really? Since this field is a mask, the first bit denotes the first byte of the instruction, and so on, starting at 'addr' field. Basically use the following code:
{{{
for (int i = 0; i < sizeof(uint16_t); i++) {
 if (DecomposedInst.unusedPrefixesMask & (1 << i))
  printf("Unused prefix %02x at offset: %x\n", CodeBuffer[DecomposedInst.addr - StartCodeOffset + i], DecomposedInst.addr + i); 
}
}}}

<b>uint8_t meta;</b>
 * Always set.
 * This field holds meta information to the instruction.
 * It contains two sub-fields which should be extracted using the helper macros: META_GET_ISC, META_GET_FC.
 * META_GET_ISC returns the Instruction-Set-Class type of the instruction. I.E: ISC_INTEGER, ISC_FPU, and many more. See distorm.h for the complete list.
 * META_GET_FC returns the Flow-Control type of the instruction. I.E: FC_CALL, FC_BRANCH and others. Usually it's FC_NONE. See the rest of them inside distorm.h.
 * The meta-FC is very useful for flow control analysis.


===Flags===
The 'flags' field has a few more options, they are pretty advanced though, but nothing special.
Use the helper macros: FLAG_GET_OPSIZE, FLAG_GET_ADDRSIZE, FLAG_GET_PREFIX.
FLAG_GET_OPSIZE returns the DecodeType (Decode16Bits, Decode32Bits or Decode64Bits) of the operand, thus it's the size of the operand.

FLAG_GET_ADRSIZE returns the DecodeType (Decode16Bits, Decode32Bits or Decode64Bits) of the operand, thus it's the size of the referenced memory by the operand.

It is important to understand the meaning of the two sizes:
{{{MOV EAX, EBX}}} - operand size is 32 in both operands.
{{{MOV [EAX], byte ptr 0}}} - operand size is 8 in both operands, however the size of the register that references the memory, EAX, is obviously 32 (or Decode32Bits).

FLAG_GET_PREFIX returns the prefix of the instruction (FLAG_LOCK, FLAG_REPNZ, FLAG_REP).

There are a few more flags such as:
FLAG_HINT_TAKEN, FLAG_HINT_NOT_TAKEN, FLAG_IMM_SIGNED.
You can check for these flags by doing: if ((DecomposedInst.flags & FLAG_XXX) != 0)
The first two are pretty self-explanatory, if you know what they mean :)
The FLAG_IMM_SIGNED is important if you want to know whether to treat the immediate as a signed or unsigned integer (some instructions supply this information).

===Operands===

===Immediate===
The 'immediate' field should be treated very carefully. If you will take a closer look it is defined as a _Value type, which looks like this:
{{{
typedef union {
	/* Used by O_IMM: */
	int8_t sbyte;
	uint8_t byte;
	int16_t sword;
	uint16_t word;
	int32_t sdword;
	uint32_t dword;
	int64_t sqword;
	uint64_t qword;

	/* Used by O_PC: */
	_OffsetType addr;

	/* Used by O_PTR: */
	struct {
		uint16_t seg;
		/* Can be 16 or 32 bits, size is in ops[n].size. */
		uint32_t off;
	} ptr;

	/* Used by O_IMM1 (i1) and O_IMM2 (i2). ENTER instruction only. */
	struct {
		uint32_t i1;
		uint32_t i2;
	} ex;
} _Value;
}}}
