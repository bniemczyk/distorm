#summary A must read for using the Decompose interface.

In this page I'm going to cover how to parse the Decompose output.

Valid instructions
Invalid instructions
Basic fields
Use macros


struct _DInst:
 
<b>_OffsetType addr;</b>
 * Always set.
 * The virtual address of the instruction.
 * It is determined according to the given start address of the call to the Decompose function.

<b>uint8_t size;</b>
 * Always set.
 * The size of the whole instruction. Varying from 1 to 15 bytes long.

<b>uint16_t flags;</b>
 * Always set.
 * Very important to check this field before touching the other fields.
 * If it's set to FLAG_NOT_DECODABLE, the instruction is invalid.

<b>uint8_t segment;</b>
 * Set when one of the operands is of type O_SMEM, O_MEM, O_DISP.
 * Helper macros: SEGMENT_GET, SEGMENT_IS_DEFAULT.
 * SEGMENT_IS_DEFAULT returns TRUE if the segment register is the default one for the operand. For instance: MOV [EBP], AL - the default segment register is SS. However, MOV [FS:EAX], AL - The default segment is DS, but we overrode it with FS, therefore the macro will return TRUE.
 * To extract the segment register index use the SEGMENT_GET macro.
 * R_NONE if not set.

<b>uint8_t base;</b>
 * Set when one of the operands is of type O_MEM.
 * It is the register index of the Base. I.E: MOV [EAX+EBX*4], EDI - it is R_EAX.
 * R_NONE if not set.

<b>uint8_t scale;</b>
 * Set when one of the operands is of type O_MEM.
 * The Scale is a pair to the Index register in a memory indirection operand, which is described in the Operand structure.
 * The scale can be either 0, 1, 2, 4, 8. If it's not set it is 0.

<b>uint8_t dispSize;</b>
 * Set when one of the operands is of type O_SMEM, O_MEM, O_DISP and the instruction has a displacement.
 * This is the size of the 'disp' field in bytes.
 * If there's no displacement set, this field is 0.

<b>uint16_t opcode;</b>
 * Always set.
 * If the instruction is invalid it is set to I_UNDEFINED.
 * Include the file "mnemonics.h" to use the Instructions-Enum.
 * An helper macro to get the textual representation for an instruction is GET_MNEMONIC_NAME.
 * For instance, if you want to check that a decomposed instruction is 'POP', then compare this field to I_POP. Basically add a prefix of "I_" to the upcased name of the instruction you want to check. You can see the whole list in the "mnemonics.h" file.

<b>_Operand ops[OPERANDS_NO];</b>

<b>uint64_t disp;</b>
 * Set when one of the operands is of type O_SMEM, O_MEM, O_DISP and the instruction has a displacement.
 * The only way to know that an instruction as a displacement is to check that dispSize != 0.
 * Some instructions use a displacement of 0. I.E: MOV [EBP], EAX.

<b>_Value imm;</b>
<b>uint16_t unusedPrefixesMask;</b>
<b>uint8_t meta;</b>
 * Always set.
 * This field holds meta information to the instruction.
 * It contains two sub-fields which should be extracted using the helper macros: META_GET_ISC, META_GET_FC.
 * META_GET_ISC returns the Instruction-Set-Class type of the instruction. I.E: ISC_INTEGER, ISC_FPU, and many more. See distorm.h for the complete list.
 * META_GET_FC returns the Flow-Control type of the instruction. I.E: FC_CALL, FC_BRANCH and others. Usually it's FC_NONE. See the rest of them inside distorm.h 