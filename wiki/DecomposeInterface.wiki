#summary A must read for using the Decompose interface.

In this page I'm going to cover how to parse the Decompose output.

Valid instructions
Invalid instructions
Basic fields
Use macros


struct _DInst:

<b>_OffsetType addr;</b>
 * Always set.
 * The virtual address of the instruction.
 * It is determined according to the given start address of the call to the Decompose function.

<b>uint8_t size;</b>
 * Always set.
 * The size of the whole instruction. Varying from 1 to 15 bytes long.

<b>uint16_t flags;</b>
 * Always set.
 * Very important to check this field before touching the other fields.
 * If it's set to FLAG_NOT_DECODABLE, the instruction is invalid.

<b>uint8_t segment;</b>
 * Set when one of the operands is of type O_SMEM, O_MEM, O_DISP.
 * Helper macros: SEGMENT_GET, SEGMENT_IS_DEFAULT.
 * SEGMENT_IS_DEFAULT returns TRUE if the segment register is the default one for the operand. For instance: MOV [EBP], AL - the default segment register is SS. However, MOV [FS:EAX], AL - The default segment is DS, but we overrode it with FS, therefore the macro will return TRUE.
 * To extract the segment register index use the SEGMENT_GET macro.
 * R_NONE if not set.

<b>uint8_t base;</b>
 * Set when one of the operands is of type O_MEM.
 * It is the register index of the Base. I.E: MOV [EAX+EBX*4], EDI - it is R_EAX.
 * R_NONE if not set.

<b>uint8_t scale;</b>
 * Set when one of the operands is of type O_MEM.
 * The Scale is a pair to the Index register in a memory indirection operand, which is described in the Operand structure.
 * The scale can be either 0, 1, 2, 4, 8. If it's not set it is 0.

<b>uint8_t dispSize;</b>
 * Set when one of the operands is of type O_SMEM, O_MEM, O_DISP and the instruction has a displacement.
 * This is the size of the 'disp' field in bytes.
 * If there's no displacement set, this field is 0.

<b>uint16_t opcode;</b>
 * Always set.
 * If the instruction is invalid it is set to I_UNDEFINED.
 * Include the file "mnemonics.h" to use the Instructions-Enum.
 * An helper macro to get the textual representation for an instruction is GET_MNEMONIC_NAME.
 * For instance, if you want to check that a decomposed instruction is 'POP', then compare this field to I_POP. Basically add a prefix of "I_" to the upcased name of the instruction you want to check. You can see the whole list in the "mnemonics.h" file.

<b>_Operand ops[OPERANDS_NO];</b>

<b>uint64_t disp;</b>
 * Set when one of the operands is of type O_SMEM, O_MEM, O_DISP and the instruction has a displacement.
 * The only way to know that an instruction as a displacement is to check that dispSize != 0.
 * Some instructions use a displacement of 0. I.E: MOV [EBP], EAX.

<b>_Value imm;</b>
<b>uint16_t unusedPrefixesMask;</b>
 * Always set.
 * This field indicates which of the prefixes of the instruction were unused.
 * There are two reasons as for why a prefix is unused, either because it didn't affect the decoding of the instruction. I.E: db 0x66; ADD AL, 1. The 0x66 (Operand Size) prefix doesn't affect the instruction in this case and therefore is unused. The other reason is when there are more than one prefix of the same type (see x86 documentation). I.E: db 0x2e, db 0x3e, MOV [EAX], AL. We tried to set a segment override twice, so only the last one (0x3e) is taken into account, the first one is unused.
 * Normally instructions *should not* have unused prefixes. It might mean that you disassemble invalid code (or data). Or it might mean you disassemble an aligning instruction such as: 0x66, 0x66, 0x90 to fill in a space of 3 bytes to round up to next multiple of 8/16, etc.
 * A quick check to see if the instruction has unused prefixes is 'unusedPrefixesMask != 0'.
 * So which prefixes are unused really? Since this field is a mask, the first bit denotes the first byte of the instruction, and so on, starting at 'addr' field. Basically use the following code:

for (int i = 0; i < sizeof(uint16_t); i++) {
 if (DecomposedInst.unusedPrefixesMask & (1 << i))
  printf("Unused prefix %02x at offset: %x\n", CodeBuffer[DecomposedInst.addr - StartCodeOffset + i], DecomposedInst.addr + i); 
}

<b>uint8_t meta;</b>
 * Always set.
 * This field holds meta information to the instruction.
 * It contains two sub-fields which should be extracted using the helper macros: META_GET_ISC, META_GET_FC.
 * META_GET_ISC returns the Instruction-Set-Class type of the instruction. I.E: ISC_INTEGER, ISC_FPU, and many more. See distorm.h for the complete list.
 * META_GET_FC returns the Flow-Control type of the instruction. I.E: FC_CALL, FC_BRANCH and others. Usually it's FC_NONE. See the rest of them inside distorm.h.
 * The meta-FC is very useful for flow control analysis.